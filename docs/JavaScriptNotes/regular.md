### 正则
**定义：** 正则表达式是一些用来匹配和处理文本的字符串。

#### 运用的场景
1.查找特定的信息（搜索）
2.查找并编辑特定的信息（替换）


#### 正则在js中的运用
- exec：用来搜索 **一个** 匹配的 RegExp 对象方法
- match：用来匹配 **一个** 字符串的 String 对象方法
- replace：用来执行替换操作 Sting 对象方法
- search：是否存在 String 对象方法
- split：把一个字符串拆分成多个子串的 String 对象方法
- test：是否存在 RegExp 对象方法
:::tip 注意
g：表示开启全局搜索

i：不区分大小写

两者合并，可以写成 gi
:::


```js
// esec 👇
/my/.exec('dsds my dsdsddmydsdsdd')
// ["my", index: 5, input: "dsds my dsdsddmydsdsdd", groups: undefined]

// match 👇
'dsadsadmymydsadmnymy'.match(/my/)
// ["my", index: 7, input: "dsadsadmymydsadmnymy", groups: undefined]

// replace 👇
'my sdsdsmy dsmyds'.replace(/my/gi, '11')
// "11 sdsds11 ds11ds"
```



**普通文本匹配**

 `/my/.test('my name is xxxx')`

通过上诉，就可简单匹配文本中是否出现了 my 这个内容。


**有多个匹配结果**

js中，使用 g 开启全局搜索，然后可以使用 exec or math，可以将匹配到的所有内容，以数组形式返回。

使用 i 不区分大小写，默认是区分大小写的。


**匹配任意字符**

.  字符：表示可以匹配任意单个字符。(包括自身的 . 字符)

```js
/my....../.exec('dsdsddmy1321321')
// ["my132132", index: 6, input: "dsdsddmy1321321", groups: undefined]
```
:::tip
. 字符也可以加在前面。如果超出长度，则上面的正则将返回 null。（就和匹配不到一样，返回 null）
:::


**匹配特殊字符**

比如我们想要匹配上面的 . 字符

` /\./.test('.dsdsd')`  : 通过前面加一个 \ 实现。



**匹配多个字符中的某一个**

可以使用 [ ] 来定义字符合集。结果必须匹配合集中的某一个。

```js
/[ns]a.\.xls/.exec('saw.xls')
```

像是可以匹配 0-9，a-z 这种大量内容的，可以使用 连字符（-）来定义字符区间。

```js
/[ns]a[0-9]\.xls/.exec('saw.xls')
```

**排除**

有时候，需要反向判定：如👇，在满足其它的条件下，排除掉 第三位是0-9的。

```js
/[ns]a[^0-9]\.xls/.exec('sa1.xlssaw.xlssa1.xlssa1.xls')
/[ns]a[^0-9a-z]\.xls/.exec('sa1.xlssaW.xlssa1.xlssa1.xls') // 这种情况下，第三位是a-z的也无法匹配
```

:::tip
 ^的效果将作用域给定**字符合集**（[0-9]）里的所有字符 或 **字符区间**（0-9）里的所有字符。
:::


**关于元字符**

像是之前使用过的 `. [ ] \` 这些字符，在正则表达式中有特殊含义的。在前面加上  ‘ \ ’。



**匹配空白字符**

[\b] :  回退（并删除）一个字符（Backspace键）
\f	:  换页符

\n   :  换行符

\r	:  回车符

\t	:  制表符（Tab 键）

\v    : 垂直制表符

**匹配特定的字符类型**

1. 匹配数组（非数字）

   \d：任何一个数字字符

   \D：任何一个非数字字符

2. 匹配字母数字

   \w：等价于`[a-zA-Z0-9_]`

   \W：非，等价于`[^a-zA-Z0-9_]`

3. 匹配空白字符（都不包含退格符）

   \s：任何一个空白字符`[\f\n\r\t\v]`

   \S：非：`[^\f\n\r\t\v]`



#### 重复匹配

问题： 需要匹配多个不定位数的字符，比如说邮箱格式。@ 前面的位数是不定项的，所以 👇

**匹配一个或多个字符**

+：匹配一个或多个连续字符（至少一个，不匹配0字符情况）

```js
'12323123weewe123213'.match(/[0-9]+/g)
// ["12323123", "123213"]
```

简单的邮箱 格式校验：

```js
'ben@forta.com'.match(/\w+@\w+.\w+/)
// 优化 👇
'ben.shx@forta.hsh.com'.match(/[\w.]+@[\w.]+.\w+/)
```

但是 + 匹配最少也必须要有 一个，如果想匹配零个或多个呢？ 👇

**匹配零个或多个字符**

*：（使其可选）👇，必须要以数字，字母，下划线开头

```js
'.ben@forta.com'.match(/\w+[\w.]*@[\w.]+.[\w.]+/)
```

**匹配零个或一个字符**

?：不出现 or 只出现一次

```js
'https://www.baidu.com/'.match(/http[s]?:\/\/[\w.\/]+/)
// 虽然只有一个集合，但是【】起来可以增加可读性。
// 使用？表示前面的s出现的次数，可以是0 or 1次。
```

**匹配的重复次数**

因为无法指定具体的匹配次数，那么遇到需要指定上限和下限的怎么办呢？

重复范围：=>  `{}`

🌰：{3}：出现了三次，

​		 {2, 4}：出现了 2-4 次

​		 {3, }：至少重复多少次

```js
'#000fff'.match(/#[A-Fa-f0-9]{6}/) 
'#000ff'.match(/#[A-Fa-f0-9]{2,5}/)
```

**防止过度匹配**

```js
'<b>AK</b> <b>dsdsdsd</b>'.match(/<[Bb]>.*<\/[Bb]>/)
// 结果：整个字符串都被选中了
```

原因：* ,  +,  {n,}都是 贪婪型元字符，匹配方式是多多益善。

解决：懒惰型量词 => *?  ,  +？, {n, }?

```js
'<b>AK</b> <b>dsdsdsd</b>'.match(/<[Bb]>.*?<\/[Bb]>/)
// 只有 <b>AK</b> 被选中了
```



#### 位置匹配

**边界**

用于指定模式前后位置（或边界）的特殊元字符。

**单词边界**

\b：指定的单词边界，用来匹配一个单词的开头或结尾。

其实就是匹配单词为 cat 的， 而其他单词里面有 cat 的不算在内。所以叫单词边界👇

```js
'cat ssdsd cat sddcat sdsd'.match(/\bcat\b/g)
// ["cat", "cat"]

/\bcat/  => // 表示匹配cat开头的单词 只匹配 cat 部分
/cat\b/  => // 表示匹配cat结尾的单词 只匹配 cat 部分

'sends sdds end endsd sdend'.match(/\Bend\B/)
// 只匹配到了第一个 sends 中的 end。也就是非单词边界的内容
```

**字符串边界**

有两个元字符：^代表字符串开头，$代表字符串结尾。

​		关于^：有两个用途，只有其在 `[]`之间，且紧跟在 [^ 这里的时候表示 => 排除。

**作用：** 比如有些需求：必须出现在开头，or  必须出现在结尾。这时就会出现问题，如👇

```js
// 如下，这样验证是没有问题的
'<?xml version="1.0" encoding=""UTF-8 ?>'.match(/<\?xml.*\?>/)
// 但是，这样时，标签已经不是在开头出现了，但是还是能匹配的到
'fhsfdgsfdgfd<?xml version="1.0" encoding=""UTF-8 ?>'.match(/<\?xml.*\?>/)
```

因此：^的用处凸显出来了（从最开始匹配）

```js
' <?xml version="1.0" encoding=""UTF-8 ?>'.match(/^\s*<\?xml.*\?>/)
// 前面允许有空字符
```

$ 从最后开始匹配

```js
'<html>jhdsjdshdjsdhjshd</html>'.match(/<\/[Hh][Tt][Mm][Ll]>\s*$/)
// 后面允许有空字符
```

**多行模式**

(?m)：用于开启多行模式。必须出现在整个模式的最前面。

warning！！！！ js里面不支持（?m）



#### 使用子表达式

出现的原因：因为{2, }制定的重复次数只作用于紧挨着它的前一个字符。

如下： 

```js
'tom tom sdssdsdtommm'.match(/tom{3,}/)
// 匹配到的是tommm，而不是我们想要的出现三次 tom
```

使用 `()` 子表达式进行分组。

```js
'tomtom sdssdsdtommm'.match(/(tom){2,}/)
// 匹配到了 tomtom
```

🌰： 适配 IP 地址

```js
'12.159.46.200'.match(/(\d{1,3}.){3}\d{1,3}/)
```

tips =>  | 表示OR(或) 操作符

```js
'1929 23923 2012 20123'.match(/(19|20)\d{2}/g)
```

这时候，使用或者模式就应该要使用子表达式。

**子表达式的嵌套**

正则表达式只是匹配字符，并不了解这些字符的含义

所以遇到如上 的 IP 地址的适配每一段的最大值不能超过 255 ，这种怎么判定呢？

(o゜▽゜)o☆[BINGO!]， 穷举法，把所有情况全部列举出来就好了....

```js
/^(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2}))\.){3}(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1,2})))$/.exec('245.157.46.25')
// 模式是从左向右进行匹配的哦,所以书写的时候要注意满足的是最大值，还是最小值情况。
// 这里 开头和结尾要加上 ^ $ 位置匹配才行哦

// 这样写貌似更简单一些。
/^((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}$/
```



#### 反向引用

指的是这些实体引用的是先前的字表达式。

适用场景：一段文本中，找出所有连续重复出现的单词

```js
/[ ]+(\w+)[ ]+\1/.exec('hi this this')
```

一些理解：

​		\1表示前面的子表达式所匹配到的内容。

​		\ num，num就表示第几个表达式。比如上🌰，(\w+)匹配到的是 this，后面\1匹配到的应该也是this

​		\ 0表示整个正则表达式

问题：这是相对位置，一旦增删改查，位置发生了变化，引用会失效。所以需要一个 ‘命名捕获’ 给字表达式起一个唯一的命名，各语言的支持不同。

**替换操作**

替换操作在 JavaScript 中的使用。

使用 replace 方法，进行替换 如 👇

| 变量名            | 代表的值                                                     |
| ----------------- | ------------------------------------------------------------ |
| `match`           | 匹配的子串。（对应于上述的$&。）                             |
| `p1,p2, ...`      | 假如replace()方法的第一个参数是一个[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是用 `/(\a+)(\b+)/` 这个来匹配，`p1` 就是匹配的 `\a+`，`p2` 就是匹配的 `\b+`。 |
| `offset`          | 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 `'abcd'`，匹配到的子字符串是 `'bc'`，那么这个参数将会是 1） |
| `string`          | 被匹配的原字符串。                                           |
| NamedCaptureGroup | 命名捕获组匹配的对象                                         |



```js
function replacer(match, p1, p2, p3, offset, string) {
    console.log(match, p1, p2, p3, offset, string)
    // 参数结果如下
    // abc12345#$*%    abc     12345    #$*%    0    abc12345#$*%
    return [p1, p2, p3].join(' - ');
}
var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
```



#### 环视

用来标记要匹配文本的位置（而不是文本自身）

向前查看， 向后查看（部分语言拥有）

👇（?=）

```js
/.+(?=:)/.exec('https:dsdwdsdw')
// 匹配到的是：前面的 https 不包含：符号
```

 👇 (?<=)

```js
/(?<=\$)[0-9.]+/.exec('$123')
// 匹配到的是 123 没有$符号。这种场景就可以使用到，需要以$ 为标识，但是在匹配中不出现。 
```

所谓的向前看，向后看不是根据这两个标识来判定的，而是根据是保留标识前还是标识后的字符来确定的

👇🌰 （注意保留字段是在前，还是后）

```js
'234endsdf'.match(/.+(?<=end)/) 	// 234end
'234endsdf'.match(/.+(?=end)/)		// 234
'234endsdf'.match(/(?=end).+/)		// endsdf
'234endsdf'.match(/(?<=end).+/)		// sdf
```



两者结合使用，就可查询到  **两个标识之间**  的内容

**否定式环视**

否定式向前看：👇 （?!）

否定式向后看：👇	(?<!)

```js
'$32 $355 345 34 23 435'.match(/\b(?<!\$)\d+\b/g)
```



#### 嵌入式条件

出现这样的情况如果出现了 （  就要有 ），否则就要有一个 — 匹配。

这种情况下就需要使用 条件处理。

正则里面：条件语法使用 ？的原因：出现的情况主要有两种：

1.根据反向引用来进行条件处理

2.根据环视来进行条件处理

**反向引用条件**

`(?(backreferce)true)` ：表示只有前面的引用模式生效了，才会执行反向引用部分的内容

```js
// 👇 表示匹配

/(<[Aa]\s+[^>]+>\s*)?<[Ii][Mm][Gg]\s+[^>]+>(?(1)\s*<\/[Aa]>)/
// 貌似 js 不支持该模式 并且不推荐使用
```



`(?(backreference)true|false)` :表示前面的引用模式生效就执行 true 部分的语句，否则就执行 false 部分的语句

```js
/(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}/
// 条件语句中可以使用 | 语句
```

**环视条件**





#### 练习题

1.IP地址练习

要求： 由四个字节组成，每个字节范围 0~255，以 . 区分的整数。



2.完整的URL





##### 简单正则练习

**匹配整数或者小数（包括正数和负数）**

业务场景：

​		只能输入整数和小数

```js
// 解决只能输入整数和小数问题的处理
// 模拟双向绑定的数据
let modelValue = ''
let str = '123.232sdsd3.444'
let arr = str.match(/\d+(\.\d+)?/)
modelValue = arr[0]
console.log(modelValue)
```



**判定日期是否合法**

```js
let needVaildDate = '1823-09-31'

function replacer(match, p1, p2, p3) {
    let isLeapYear = false
    let big = ['01','03','05','07','08','10', '12'].includes(p2)
    let small = ['04','06','09','11'].includes(p2)
    let two = ['02'].includes(p2)
    // 判断是是否是闰年
    p1 % 4 === 0 && (isLeapYear = true)
    // 判断月份对应日期是否合法
    if (big) ~~p3 <= 31 ? p3 : p3 = '31'
    if (small) ~~p3 <= 30 ? p3 : p3 = '30'
    if (isLeapYear && two) ~~p3 <= 29 ? p3: p3 = '29'
    if (!isLeapYear && two) ~~p3 <= 28 ? p3: p3 = '28'
    return `${p1}/${p2}/${p3}`
}

let rightStr = ''
let firstVaild = /^([1-9]\d{0,3})-(1[0-2]|0[1-9])-(3[01]|[12]\d|0[1-9])$/.test(needVaildDate)
firstVaild
    ? rightStr = needVaildDate.replace(/([1-9]\d{0,3})-(1[0-2]|0[1-9])-(3[01]|[12]\d|0[1-9])/, replacer)
	: alert('格式不符合要求')

console.log(rightStr);
```



找到 h1-h6 格式正确的标签。标签之间的内容

如： →  `<h2>qweswds</h2>` ，确保是正确的标签后，获取标签之间的内容

```js
'<h2>sdsdsd</h2>'.match(/(?<=<h([1-6])>).*(?=<\/h\1>)/)
// 这么写的两个问题：
	// 1. 应该使用惰性匹配： 不然<h1><h1>qwe</h1></h1>也会被匹配到
	// 2. 所有字符匹配使用[\s\S]
// sdsdsd
(?<=<(h[1-6])>\s*)\S[\s\S]*?(?=\s*<\/\1>)
(?<=<(h[1-6])>)[\s\S]*?(?=\s*<\/\1>)
// 前者可以去掉前后空格，缺点是中间没有或者都是空字符就匹配不到，
// 后者都可以匹配，缺点是需要二次处理前置空字符            
            
```


### 练习笔记

\(0^◇^0)  **some log 👇**

1. 关于什么都可以填的操作

使用`.*`匹配的话，是匹配不到换行符的。可以使用 [\S\s] 匹配所有字符



2. 匹配 html string
 - 1. 一个完整的标签，从第一个开始，如果是只有一个标签则只会返回一个匹配结果
 
 /<(\S*)[^>]*>[\S]*?<\/(\1)>/g
 - 2. 匹配类似 `<img />` 标签这种单标签
 
 /<[^>]*\/>/g


用来匹配 富文本标签 用来拆分成多个元素分别渲染（简单版，只能是最外层的标签）

*? 防止贪婪匹配
/<(\S*)[^>]*>[\s\S]*?<\/(\1)>|<[^>]*\/>/g
1. 只能是最外层，平级的标签拆分
2. 相同标签嵌套无法处理，比如 `<div> <div>wwww</div> </div>`


